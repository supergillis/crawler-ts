export type ValueOrPromise<T> = T | Promise<T>;

export interface Logger {
  info: (...args: any[]) => void;
  debug: (...args: any[]) => void;
  error: (...args: any[]) => void;
}

export interface RequesterOptions<L> {
  readonly location: L;
}

export interface RequesterResult<L, R> extends RequesterOptions<L> {
  readonly response?: R;
}

export interface ParserOptions<L, R> extends RequesterOptions<L> {
  readonly response: R;
}

export interface ParserResult<L, R, P> extends ParserOptions<L, R> {
  readonly parsed?: P;
}

export interface FollowerOptions<L, R, P> extends ParserOptions<L, R> {
  readonly parsed: P;
}

export type Requester<L, R> = (options: RequesterOptions<L>) => ValueOrPromise<RequesterResult<L, R>>;
export type Parser<L, R, P> = (options: ParserOptions<L, R>) => ValueOrPromise<ParserResult<L, R, P>>;
export type Follower<L, R, P> = (options: FollowerOptions<L, R, P>) => AsyncGenerator<L>;

/**
 * @type {L} The type of the locations to crawl, e.g. `URL` or `string` that represents a path.
 * @type {R} The type of the response at the location that is crawler, e.g. Cheerio object, file system `fs.Stats`.
 * @type {P} The intermediate parsed result that can be parsed from the response and generated by the crawler.
 */
export interface CrawlerOptions<L, R, P> {
  /**
   * This function should return the response for the given location.
   */
  requester: Requester<L, R>;
  /**
   * This function should parse the response and convert the response to the parsed type.
   */
  parser: Parser<L, R, P>;
  /**
   * This function should yield all the locations to follow in the given parsed result.
   */
  follower: Follower<L, R, P>;
  /**
   * The logger can be set to `console` to output debug information to the `console`.
   *
   * @default undefined
   */
  logger?: Logger;
}

export type Crawler<L, R, P> = (start: L) => AsyncGenerator<FollowerOptions<L, R, P>>;

export function createCrawler<L, R, P>(options: CrawlerOptions<L, R, P>): Crawler<L, R, P> {
  const { requester, parser, follower, logger } = options;

  return async function* gen(location: L): AsyncGenerator<FollowerOptions<L, R, P>> {
    try {
      logger?.debug(`Requesting ${location}`);
      const requesterResult = await requester({ location });
      if (!isParserOptions(requesterResult)) {
        return;
      }

      logger?.debug(`Parsing ${location}`);
      const parserResult = await parser(requesterResult);
      if (!isFollowerOptions(parserResult)) {
        return;
      }

      logger?.debug(`Yielding ${location}`);
      yield parserResult;

      for await (const next of follower(parserResult)) {
        try {
          logger?.debug(`Queueing ${next}`);
          yield* gen(next);
        } catch (e) {
          logger?.error(`Cannot queue ${next}`);
          logger?.error(e);
        }
      }
    } catch (e) {
      logger?.error(`Cannot visit ${location}`);
      logger?.error(e);
    }
  };
}

export function isParserOptions<L, R>(result: RequesterResult<L, R>): result is ParserOptions<L, R> {
  return result.response !== undefined && result.response !== null;
}

export function isFollowerOptions<L, R, P>(result: ParserResult<L, R, P>): result is FollowerOptions<L, R, P> {
  return result.parsed !== undefined && result.parsed !== null;
}
