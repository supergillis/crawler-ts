import { FlatMapFn, iter, of } from './iterators';

export interface Logger {
  info: (...args: any[]) => void;
  debug: (...args: any[]) => void;
  error: (...args: any[]) => void;
}

export interface RequesterOptions<L> {
  readonly location: L;
}

export interface ParserOptions<L, R> extends RequesterOptions<L> {
  readonly response: R;
}

export interface FollowerOptions<L, R, P> extends ParserOptions<L, R> {
  readonly parsed: P;
}

export type Requester<L, R> = FlatMapFn<RequesterOptions<L>, ParserOptions<L, R> | undefined>;
export type Parser<L, R, P> = FlatMapFn<ParserOptions<L, R>, FollowerOptions<L, R, P> | undefined>;
export type Yielder<L, R, P> = FlatMapFn<FollowerOptions<L, R, P> | undefined>;
export type Follower<L, R, P> = FlatMapFn<FollowerOptions<L, R, P>, L | undefined>;

export type Crawler<L, R, P> = (start: L) => AsyncIterableIterator<FollowerOptions<L, R, P>>;

/**
 * @type {L} The type of the locations to crawl, e.g. `URL` or `string` that represents a path.
 * @type {R} The type of the response at the location that is crawler, e.g. Cheerio object, file system `fs.Stats`.
 * @type {P} The intermediate parsed result that can be parsed from the response and generated by the crawler.
 */
export interface CrawlerOptions<L, R, P> {
  /**
   * This function should return the response for the given location.
   */
  requester: Requester<L, R>;
  /**
   * This function should parse the response and convert the response to the parsed type.
   */
  parser: Parser<L, R, P>;
  /**
   * This function should yield all the locations to follow in the given parsed result.
   */
  yielder?: Yielder<L, R, P>;
  /**
   * This function should yield all the locations to follow in the given parsed result.
   */
  follower: Follower<L, R, P>;
  /**
   * The logger can be set to `console` to output debug information to the `console`.
   *
   * @default undefined
   */
  logger?: Logger;
}

export const defaultYielder: Yielder<any, any, any> = (options) => options;

export function createCrawler<L, R, P>(options: CrawlerOptions<L, R, P>): Crawler<L, R, P> {
  const { requester, parser, yielder = defaultYielder, follower, logger } = options;

  return async function* gen(location: L): AsyncIterableIterator<FollowerOptions<L, R, P>> {
    try {
      logger?.debug(`Requesting ${location}`);

      // prettier-ignore
      const followerOptions = iter({ location })
        .flatMap(requester)
        .is(isDefined, () => logger?.debug(`Not allowing request for ${location}`))
        .flatMap(parser)
        .is(isDefined, () => logger?.debug(`Not allowing parsing for ${location}`));

      for await (const followerOption of followerOptions) {
        // prettier-ignore
        yield* iter(followerOption)
          .flatMap(yielder)
          .is(isDefined, () => logger?.debug(`Not allowing yield for ${location}`));

        // prettier-ignore
        yield* iter(followerOption)
          .flatMap(follower)
          .is(isDefined, () => logger?.debug(`Not allowing follow for ${location}`))
          .catch((e) => logger?.error(`Cannot queue ${location}`, e))
          .flatMap(gen);
      }
    } catch (e) {
      logger?.error(`Cannot visit ${location}`);
      logger?.error(e);
    }
  };
}

export function isDefined<T>(value: T | undefined): value is T {
  return value !== undefined;
}
