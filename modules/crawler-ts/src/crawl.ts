type ValueOrPromise<T> = T | Promise<T>;

export interface Logger {
  info: (...args: any[]) => void;
  error: (...args: any[]) => void;
}

/**
 * @type {Location} The type of the locations to crawl, e.g. `URL` or `string` that represents a path.
 * @type {Response} The type of the response at the location that is crawler, e.g. Cheerio object, file system `fs.Stats`.
 * @type {Result} The intermediate result that can be parsed from the response and generated by the crawler.
 */
export interface Config<Location, Response, Result> {
  /**
   * This function should return the response for the given location.
   */
  requester(loc: Location): ValueOrPromise<Response | undefined>;
  /**
   * This function should return true if the crawler should parse the response, or false if not.
   */
  shouldParse(loc: Location, response: Response): ValueOrPromise<boolean>;
  /**
   * This function should parse the response and convert the response to the result type.
   */
  parser(loc: Location, response: Response): ValueOrPromise<Result | undefined>;
  /**
   * This function should return true if the crawler should yield the result, or false if not.
   */
  shouldYield(result: Result): ValueOrPromise<boolean>;
  /**
   * This function should yield all the locations to follow in the given result.
   */
  follower(result: Result): AsyncGenerator<Location>;
  /**
   * This function should return true if the crawler should queue the location for crawling, or false if not.
   */
  shouldQueue(loc: Location): ValueOrPromise<boolean>;
  /**
   * The logger can be set to `console` to output debug information to the `console`.
   *
   * @default undefined
   */
  logger?: Logger;
}

export function crawl<Location, Response, Result>(
  config: Config<Location, Response, Result>
): (start: Location) => AsyncGenerator<Result> {
  const {
    requester,
    shouldParse,
    parser,
    shouldYield,
    follower,
    shouldQueue,
    logger,
  } = config;

  return async function* gen(loc: Location): AsyncGenerator<Result> {
    try {
      logger?.info(`Requesting ${loc}`);
      const response = await requester(loc);
      if (response && (await shouldParse(loc, response))) {
        logger?.info(`Parsing ${loc}`);
        const result = await parser(loc, response);
        if (!result) {
          return;
        }

        if (await shouldYield(result)) {
          logger?.info(`Yielding ${loc}`);
          yield result;
        }

        for await (const next of follower(result)) {
          try {
            if (await shouldQueue(next)) {
              logger?.info(`Queueing ${next}`);
              yield* gen(next);
            }
          } catch (e) {
            logger?.error(`Cannot queue ${next}`);
            logger?.error(e);
          }
        }
      }
    } catch (e) {
      logger?.error(`Cannot visit ${loc}`);
      logger?.error(e);
    }
  };
}
